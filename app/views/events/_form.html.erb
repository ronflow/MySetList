<%= form_with(model: event) do |form| %>
  <% if event.errors.any? %>
    <div style="color: red">
      <h2><%= pluralize(event.errors.count, "error") %> prohibited this event from being saved:</h2>
      <ul>
        <% event.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div>
    <%= form.label :Data_do_Evento, style: "display: block" %>
    <%= form.date_field :event_date %>
  </div>

  <br>

  <div>
    <%= form.label :Descrição, style: "display: block" %>
    <%= form.text_field :description %>
  </div>

  <% 
    # Definir artists do usuário logado
    user_artists = current_user&.artists || Artist.none
    default_artist = user_artists.first || @artist = Artist.where("name ILIKE ?", "%Flowerz%").first
    selected_artist_id = event.artist_id || default_artist&.id
  %>

  <div>
    <%= form.label :artist_id, "Artista", style: "display: block" %>
    <% if user_artists.any? %>
      <%= form.collection_select :artist_id, user_artists, :id, :name, 
          { selected: selected_artist_id }, 
          { style: "display: block", id: "artist_select" } %>
    <% else %>
      <div style="background-color: #f8d7da; color: #721c24; padding: 10px; border: 1px solid #f5c6cb; border-radius: 4px;">
        <strong>Atenção:</strong> Você não possui nenhum artist associado.
        <%= link_to "Criar Artist", new_artist_path, style: "color: #721c24; text-decoration: underline;" %>
      </div>
      <%= form.hidden_field :artist_id, value: default_artist&.id %>
    <% end %>
  </div>

  <br>

  <div data-artist-sets-container>
    <%= form.label :artist_set_ids, "Sets do Artista (opcional)", style: "display: block" %>
    <div class="artist-sets-checkboxes" id="artist-sets-checkboxes">
      <!-- Sets serão carregados dinamicamente aqui -->
    </div>
    <small style="color: gray;">Selecione os sets que estarão disponíveis no evento. Se não selecionar nenhum, todas as músicas estarão disponíveis.</small>
    
    <!-- Campo hidden para manter os IDs selecionados durante a edição -->
    <% if event.persisted? %>
      <script id="selected-artist-sets" type="application/json">
        <%= event.artist_set_ids.to_json.html_safe %>
      </script>
    <% end %>
  </div>

  <br>

  <div class="form-group">
    <label for="set_tag_search"><strong>Filtrar sets por tags</strong></label>

    <!-- Campo de busca por tags (filtra os sets carregados no container acima) -->
    <input type="text" id="set_tag_search" class="form-control"
          placeholder="Buscar por tags (ex: classic, acústico, natal)" style="margin-top:8px;">
    <small class="form-text text-muted">
      Filtre a lista de sets por tags separadas por vírgula. A filtragem é feita no navegador.
    </small>
  </div>

  <br>

  <div>
    <%= form.submit %>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Elementos principais
    const artistSelect = document.getElementById('event_artist_id') || 
                         document.querySelector('select[name="event[artist_id]"]') ||
                         document.getElementById('artist_select');
    const targetContainer = document.getElementById('artist-sets-checkboxes');
    const selectedScript = document.getElementById('selected-artist-sets');
    const tagInput = document.getElementById('set_tag_search');

    if (!artistSelect) {
      console.error('Select do artist não encontrado! Todos os selects na página:', document.querySelectorAll('select'));
      return;
    }
    if (!targetContainer) {
      console.error('Container de sets não encontrado!');
      return;
    }

    // Parse sets selecionados (edição)
    function getSelectedArtistSets() {
      if (!selectedScript) return [];
      try {
        return JSON.parse(selectedScript.textContent || '[]').map(Number);
      } catch (e) {
        console.error('Erro ao parsear sets selecionados:', e);
        return [];
      }
    }
    const selectedSets = getSelectedArtistSets();

    // Função para montar um item de set com data-tags
    function createSetCheckbox(set) {
      const checkboxDiv = document.createElement('div');
      checkboxDiv.style.margin = '5px 0';
      checkboxDiv.className = 'artist-set-item';
      const tags = (set.set_tags || '').toString();
      checkboxDiv.dataset.tags = tags.toLowerCase();

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = 'event[artist_set_ids][]';
      checkbox.value = set.id;
      checkbox.id = `event_artist_set_ids_${set.id}`;
      checkbox.style.marginRight = '5px';

      if (selectedSets.includes(Number(set.id))) {
        checkbox.checked = true;
      }

      const label = document.createElement('label');
      label.textContent = set.set_list_name || set.name || `Set ${set.id}`;
      label.setAttribute('for', checkbox.id);
      label.style.cursor = 'pointer';

      // Mostrar tags ao lado do nome (se existirem)
      if (tags) {
        const small = document.createElement('small');
        small.style.color = '#666';
        small.style.marginLeft = '6px';
        small.textContent = `(${tags})`;
        checkboxDiv.appendChild(checkbox);
        checkboxDiv.appendChild(label);
        checkboxDiv.appendChild(small);
      } else {
        checkboxDiv.appendChild(checkbox);
        checkboxDiv.appendChild(label);
      }

      return checkboxDiv;
    }

    // Carrega sets do artist via JSON e popula targetContainer
    function loadArtistSets(artistId) {
      targetContainer.innerHTML = 'Carregando sets...';

      if (!artistId) {
        targetContainer.innerHTML = '<p style="color: gray; font-style: italic;">Selecione um artist para ver os sets disponíveis.</p>';
        return;
      }

      const url = `/artists/${artistId}/artist_sets.json`;
      fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      })
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
      })
      .then(data => {
        targetContainer.innerHTML = '';
        if (Array.isArray(data) && data.length > 0) {
          data.forEach(set => {
            const node = createSetCheckbox(set);
            targetContainer.appendChild(node);
          });
          // Aplica filtro atual (se houver texto no campo)
          applyTagFilter();
        } else {
          targetContainer.innerHTML = '<p style="color: gray; font-style: italic;">Este artist não possui sets cadastrados.</p>';
        }
      })
      .catch(error => {
        console.error('Erro ao carregar sets:', error);
        targetContainer.innerHTML = `<p style="color: red;">Erro ao carregar sets: ${error.message}</p>`;
      });
    }

    // Filtragem por tags: atua sobre itens em #artist-sets-checkboxes
    function applyTagFilter() {
      const q = (tagInput && tagInput.value.trim().toLowerCase()) || '';
      const terms = q.split(',').map(s => s.trim()).filter(Boolean);
      const items = Array.from(targetContainer.querySelectorAll('.artist-set-item'));
      items.forEach(item => {
        if (terms.length === 0) {
          item.style.display = '';
          return;
        }
        const tags = (item.dataset.tags || '').toLowerCase();
        const labelText = (item.textContent || '').toLowerCase();
        const matches = terms.every(t => tags.includes(t) || labelText.includes(t));
        item.style.display = matches ? '' : 'none';
      });
    }

    // Inicializa: carrega sets do artist atual (se houver)
    if (artistSelect.value) {
      loadArtistSets(artistSelect.value);
    }

    // Listener para mudança de artist
    artistSelect.addEventListener('change', function() {
      loadArtistSets(this.value);
    });

    // Listener para input de tags (filtra os itens já renderizados)
    if (tagInput) {
      tagInput.addEventListener('input', function() {
        applyTagFilter();
      });
    }
  });
  </script>
<% end %>
